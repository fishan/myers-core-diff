import { suite, test } from 'mocha';
import * as assert from 'assert';
import { MyersCoreDiff, DiffOperation, DiffResult } from '../src/myers_core_diff.js';

/**
 * Applies a diff patch to an old array of tokens to reconstruct the new array.
 * This function is the key to the robust testing strategy.
 * @param oldTokens The original array of tokens.
 * @param patch The diff patch generated by MyersDiff.
 * @returns The reconstructed new array of tokens.
 */
const applyPatch = (oldTokens: string[], patch: DiffResult[]): string[] => {
    const result: string[] = [];
    let oldTokensIndex = 0;

    for (const [op, value] of patch) {
        switch (op) {
            case DiffOperation.EQUAL:
                if (oldTokens[oldTokensIndex] !== value) {
                    throw new Error(`Patch consistency error: expected token '${oldTokens[oldTokensIndex]}' at index ${oldTokensIndex}, but patch has EQUAL with '${value}'`);
                }
                result.push(value);
                oldTokensIndex++;
                break;
            case DiffOperation.ADD:
                result.push(value);
                break;
            case DiffOperation.REMOVE:
                if (oldTokens[oldTokensIndex] !== value) {
                    throw new Error(`Patch consistency error: expected token '${oldTokens[oldTokensIndex]}' at index ${oldTokensIndex}, but patch has REMOVE with '${value}'`);
                }
                oldTokensIndex++;
                break;
        }
    }
    return result;
};


suite('MyersDiff Functional Tests (Patch Correctness)', () => {

    const runMyersTest = (title: string, oldTokens: string[], newTokens: string[]) => {
        test(title, () => {
            const myers = new MyersCoreDiff();
            const patch = myers.diff(oldTokens, newTokens);
            const reconstructedNew = applyPatch(oldTokens, patch);
            assert.deepStrictEqual(reconstructedNew, newTokens);
        });
    };

    runMyersTest(
        'should handle simple addition',
        ['line 1', 'line 3'],
        ['line 1', 'line 2', 'line 3']
    );

    runMyersTest(
        'should handle simple deletion',
        ['line 1', 'line 2', 'line 3'],
        ['line 1', 'line 3']
    );

    runMyersTest(
        'should handle simple replacement',
        ['line 1', 'old', 'line 3'],
        ['line 1', 'new', 'line 3']
    );

    runMyersTest(
        'should handle whitespace-only line replacement',
        ['line 1', '  ', 'line 3'],
        ['line 1', 'new line', 'line 3']
    );

    runMyersTest(
        'should handle move (complex change)',
        ['a', 'b', 'c'],
        ['b', 'c', 'a']
    );

    runMyersTest(
        'should handle multiple non-contiguous modifications',
        Array.from('alpha beta gamma delta'),
        Array.from('ALPHA beta GAMMA delta')
    );

    runMyersTest(
        'should handle changes involving only whitespace',
        Array.from('a b c'),
        Array.from('a\tb\tc')
    );
    
    runMyersTest(
        'should handle complete rewrite',
        Array.from('abcdefg'),
        Array.from('12345')
    );

    runMyersTest(
        'should handle deletion of all content',
        ['line 1', 'line 2'],
        []
    );
    
    runMyersTest(
        'should handle creation from empty',
        [],
        ['line 1', 'line 2']
    );
    
    runMyersTest(
        'should handle changes with unicode characters',
        Array.from('A line ğŸ˜Š.'),
        Array.from('A line ğŸš€.')
    );

    runMyersTest(
        'should return no changes for identical inputs',
        ['a', 'b', 'c'],
        ['a', 'b', 'c']
    );

    runMyersTest(
        'should handle addition at the beginning',
        ['b', 'c'],
        ['a', 'b', 'c']
    );

    runMyersTest(
        'should handle deletion from the end',
        ['a', 'b', 'c'],
        ['a', 'b']
    );

    runMyersTest(
        'should handle a moved block of tokens',
        ['prefix', 'a', 'b', 'c', 'suffix'],
        ['prefix', 'suffix', 'a', 'b', 'c']
    );

    runMyersTest(
        'should handle changes in repeating patterns',
        Array.from('ababab'),
        Array.from('acacac')
    );

    runMyersTest(
        'should handle multiple partial replacements',
        Array.from('the quick brown fox jumps'),
        Array.from('the fast brown cat leaps')
    );

    test('should handle binary-like data stress test', () => {
        const generateBinaryString = (length: number): string => {
            const bytes: number[] = [];
            for (let i = 0; i < length; i++) {
                bytes.push(i % 256);
            }
            return Buffer.from(bytes).toString('latin1');
        };

        const oldBinStr = generateBinaryString(512);
        const modBinBytes = Buffer.from(oldBinStr, 'latin1');
        modBinBytes[100] = 0xFF; // Change 'd' to 'Ã¿'
        modBinBytes[200] = 0xAA; // Change 'Ã‰' to 'Âª'
        const newBinStr = modBinBytes.toString('latin1');

        const myers = new MyersCoreDiff();
        const patch = myers.diff(Array.from(oldBinStr), Array.from(newBinStr));
        const reconstructed = applyPatch(Array.from(oldBinStr), patch);

        assert.deepStrictEqual(reconstructed.join(''), newBinStr);
    });

    runMyersTest(
        'should handle changes with long common prefix/suffix (trimmer test)',
        [...Array(100).fill('same'), 'old', ...Array(100).fill('end')],
        [...Array(100).fill('same'), 'new', ...Array(100).fill('end')]
    );

    runMyersTest(
        'should handle interleaved changes',
        ['a', 'b', 'c', 'd', 'e', 'f'],
        ['a', 'X', 'c', 'Y', 'e', 'Z']
    );
    
    runMyersTest(
        'should handle large block deletion from the middle',
        Array.from({ length: 50 }, (_, i) => `line ${i}`),
        [...Array.from({ length: 20 }, (_, i) => `line ${i}`), ...Array.from({ length: 10 }, (_, i) => `line ${i + 40}`)]
    );
});